
          config = function()
            local M = {}


            local vim = vim
            local validate = vim.validate
            local api = vim.api
            local lsp = vim.lsp
            local uv = vim.loop
            local fn = vim.fn
            local tbl_extend = vim.tbl_extend
            local function try_require(...)
              local status, lib = pcall(require, ...)
              if (status) then return lib end
              return nil
            end

            local get_root_dir = function(filename, _)
              local lspconfig = require "lspconfig"
              local root
              -- in order of preference:
              -- * git repository root
              -- * directory containing a solution file
              -- * directory containing an fsproj file
              -- * directory with fsx scripts
              root = lspconfig.util.find_git_ancestor(filename)
              root = root or lspconfig.util.root_pattern("*.sln")(filename)
              root = root or lspconfig.util.root_pattern("*.fsproj")(filename)
              root = root or lspconfig.util.root_pattern("*.fsx")(filename)
              return root
            end

            try_require("lspconfig")


            -- vim.cmd "let g:fsharp#use_recommended_server_config = 0"
            -- vim.cmd "let g:fsharp#fsautocomplete_command =    [  'fsautocomplete', '--adaptive-lsp-server-enabled', '-v' ] "
            -- vim.cmd("let $DOTNET_ROLL_FORWARD='LatestMajor'")
            -- vim.cmd "let g:fsharp#show_signature_on_cursor_move = 0"


            local lspconfig_is_present = true
            local util = try_require('lspconfig.util')
            if util == nil then
              lspconfig_is_present = false
              util = require('ionide.util')
            end

            local callbacks = {}

            vim.g['fsharp#register_callback'] = function(fn)
              if vim.g['fsharp#backend'] ~= 'nvim' then
                return -1
              end
              local rnd = os.time()
              callbacks[rnd] = fn
              return rnd
            end

            vim.g['fsharp#resolve_callback'] = function(key, arg)
              if vim.g['fsharp#backend'] ~= 'nvim' then
                return
              end
              if callbacks[key] then
                local callback = callbacks[key]
                callback(arg)
                callbacks[key] = nil
              end
            end

            local call = function(method, params, callback_key)
              local handler = function(err, result, ctx, config)
                if result ~= nil then
                  vim.g['fsharp#resolve_callback'](callback_key, {
                    result = result,
                    err = err,
                    client_id = ctx.client_id,
                    bufnr = ctx.bufnr
                  })
                  print(vim.inspect(result))
                end
              end
              vim.lsp.buf_request(0, method, params, handler)
            end

            --  function! s:PlainNotification(content)
            --    return { 'Content': a:content }
            -- endfunction

            vim.g['fsharp#PlainNotification'] = function(content)
              return { Content = content }
            end

            -- function! s:TextDocumentIdentifier(path)
            --     let usr_ss_opt = &shellslash
            --     set shellslash
            --     let uri = fnamemodify(a:path, ":p")
            --     if uri[0] == "/"
            --         let uri = "file://" . uri
            --     else
            --         let uri = "file:///" . uri
            --     endif
            --     let &shellslash = usr_ss_opt
            --     return { 'Uri': uri }
            -- endfunction

            vim.g['fsharp#TextDocumentIdentifier'] = function(path)
              local usr_ss_opt = vim.o.shellslash
              vim.o.shellslash = true
              local uri = vim.fn.fnamemodify(path, ":p")
              if string.sub(uri, 1, 1) == '/' then
                uri = "file://" .. uri
              else
                uri = "file:///" .. uri
              end
              vim.o.shellslash = usr_ss_opt
              return { Uri = uri }
            end

            -- function! s:Position(line, character)
            --     return { 'Line': a:line, 'Character': a:character }
            -- endfunction

            vim.g['fsharp#Position'] = function(line, character)
              return { Line = line, Character = character }
            end

            -- function! s:TextDocumentPositionParams(documentUri, line, character)
            --     return {
            --         \ 'TextDocument': s:TextDocumentIdentifier(a:documentUri),
            --         \ 'Position':     s:Position(a:line, a:character)
            --         \ }
            -- endfunction

            vim.g['fsharp#TextDocumentPositionParams'] = function(documentUri, line, character)
              return {
                TextDocument = vim.g['fsharp#TextDocumentIdentifier'](documentUri),
                Position = vim.g['fsharp#Position'](line, character)
              }
            end

            -- function! s:DocumentationForSymbolRequest(xmlSig, assembly)
            --     return {
            --         \ 'XmlSig': a:xmlSig,
            --         \ 'Assembly': a:assembly
            --         \ }
            -- endfunction

            vim.g['fsharp#DocumentationForSymbolRequest'] = function(xmlSig, assembly)
              return {
                XmlSig = xmlSig,
                Assembly = assembly
              }
            end

            -- function! s:ProjectParms(projectUri)
            --     return { 'Project': s:TextDocumentIdentifier(a:projectUri) }
            -- endfunction

            vim.g['fsharp#ProjectParms'] = function(projectUri)
              return {
                Project = vim.g['fsharp#TextDocumentIdentifier'](projectUri),
              }
            end

            -- function! s:WorkspacePeekRequest(directory, deep, excludedDirs)
            --     return {
            --         \ 'Directory': fnamemodify(a:directory, ":p"),
            --         \ 'Deep': a:deep,
            --         \ 'ExcludedDirs': a:excludedDirs
            --         \ }
            -- endfunction


            vim.g['fsharp#WorkspacePeekRequest'] = function(directory, deep, excludedDirs)
              return {
                Directory = string.gsub(directory, '\\', '/'),
                Deep = deep,
                ExcludedDirs = excludedDirs
              }
            end

            -- function! s:FsdnRequest(query)
            --     return { 'Query': a:query }
            -- endfunction

            vim.g['fsharp#FsdnRequest'] = function(query)
              return { Query = query }
            end

            -- function! s:WorkspaceLoadParms(files)
            --     let prm = []
            --     for file in a:files
            --         call add(prm, s:TextDocumentIdentifier(file))
            --     endfor
            --     return { 'TextDocuments': prm }
            -- endfunction

            vim.g['fsharp#WorkspaceLoadParms'] = function(files)
              local prm = {}
              for _, file in ipairs(files) do
                table.insert(prm, vim.g['fsharp#TextDocumentIdentifier'](file))
              end
              return { TextDocuments = prm }
            end

            --            local config_keys_camel = {
            --              { key = "AutomaticWorkspaceInit", default = 1 },
            --              { key = "WorkspaceModePeekDeepLevel", default = 4 },
            --              { key = "ExcludeProjectDirectories", default = {} },
            --              { key = "keywordsAutocomplete", default = 1 },
            --              { key = "ExternalAutocomplete", default = 0 },
            --              { key = "Linter", default = 1 },
            --              { key = "UnionCaseStubGeneration", default = 1 },
            --              { key = "UnionCaseStubGenerationBody" },
            --              { key = "RecordStubGeneration", default = 1 },
            --              { key = "RecordStubGenerationBody" },
            --              { key = "InterfaceStubGeneration", default = 1 },
            --              { key = "InterfaceStubGenerationObjectIdentifier", default = "this" },
            --              { key = "InterfaceStubGenerationMethodBody" },
            --              { key = "UnusedOpensAnalyzer", default = 1 },
            --              { key = "UnusedDeclarationsAnalyzer", default = 1 },
            --              { key = "SimplifyNameAnalyzer", default = 0 },
            --              { key = "ResolveNamespaces", default = 1 },
            --              { key = "EnableReferenceCodeLens", default = 1 },
            --              { key = "EnableAnalyzers", default = 0 },
            --              { key = "AnalyzersPath" },
            --              { key = "DisableInMemoryProjectReferences", default = 0 },
            --              { key = "LineLens", default = { enabled = "never", prefix = "" } },
            --              { key = "UseSdkScripts", default = 1 },
            --              { key = "dotNetRoot" },
            --              { key = "fsiExtraParameters", default = {} },
            --            }

            --            local config_keys = {}

            local function toSnakeCase(str)
              local sn = str:gsub("(%u%l+|%l+)(%u)", "%l%1_%l%2")
              if sn == str then return str:lower() end
              return sn
            end

            local function buildConfigKeys(camels)
              local keys = {}
              for _, c in ipairs(camels) do
                local key =
                function()
                  if c.default then
                    return {
                      snake = toSnakeCase(c.key),
                      camel = c.key,
                      default = c.default
                    }
                  else
                    return {
                      snake = toSnakeCase(c.key),
                      camel = c.key,
                    }
                  end
                end
                table.insert(keys, key())
              end
              return keys
            end

            -- local ionide = require("ionide")
            -- call luaeval('ionide.call(_A[1], _A[2], _A[3])', [a:method, a:params, key])
            --
            -- Call = function(method, params, key)
            --   local result = ionide.call(method, params, key)
            --   print(vim.inspect(result))
            --   return result
            -- end

            function call(method, params, callback_key)
              local handler = function(err, result, ctx, config)
                if result ~= nil then
                  vim.g['fsharp#resolve_callback'](callback_key, {
                    result = result,
                    err = err,
                    client_id = ctx.client_id,
                    bufnr = ctx.bufnr
                  })
                end
              end
              lsp.buf_request(0, method, params, handler)
            end

            vim.g['fsharp#notify'] = function(method, params)
              lsp.buf_notify(0, method, params)
            end

            Workspace = {}


            vim.g['fsharp#signature'] = function(filePath, line, character, cont)
              return call('fsharp/signature', vim.g['fsharp#TextDocumentPositionParams'](filePath, line, character),
                cont)
            end

            vim.g['fsharp#signatureData'] = function(filePath, line, character, cont)
              return call('fsharp/signatureData', vim.g['fsharp#TextDocumentPositionParams'](filePath, line, character)
                , cont)
            end

            vim.g['fsharp#lineLens'] = function(projectPath, cont)
              return call('fsharp/lineLens', vim.g['fsharp#ProjectParms'](projectPath), cont)
            end

            vim.g['fsharp#compilerLocation'] = function(cont)
              return call('fsharp/compilerLocation', {}, cont)
            end

            vim.g['fsharp#compile'] = function(projectPath, cont)
              return call('fsharp/compile', vim.g['fsharp#ProjectParms'](projectPath), cont)
            end

            vim.g['fsharp#workspacePeek'] = function(directory, depth, excludedDirs, cont)
              return call('fsharp/workspacePeek', vim.g['fsharp#WorkspacePeekRequest'](directory, depth, excludedDirs),
                cont)
            end

            vim.g['fsharp#workspaceLoad'] = function(files, cont)
              return call('fsharp/workspaceLoad', vim.g['fsharp#WorkspaceLoadParms'](files), cont)
            end

            vim.g['fsharp#project'] = function(projectPath, cont)
              return call('fsharp/project', vim.g['fsharp#ProjectParms'](projectPath), cont)
            end

            vim.g['fsharp#fsdn'] = function(signature, cont)
              return call('fsharp/fsdn', vim.g['fsharp#FsdnRequest'](signature), cont)
            end

            vim.g['fsharp#f1Help'] = function(filePath, line, character, cont)
              return call('fsharp/f1Help', vim.g['fsharp#TextDocumentPositionParams'](filePath, line, character), cont)
            end

            vim.g['fsharp#documentation'] = function(filePath, line, character, cont)
              return call('fsharp/documentation', vim.g['fsharp#TextDocumentPositionParams'](filePath, line, character)
                , cont)
            end

            vim.g['fsharp#documentationSymbol'] = function(xmlSig, assembly, cont)
              return call('fsharp/documentationSymbol', vim.g['fsharp#DocumentationForSymbolRequest'](xmlSig, assembly)
                , cont)
            end

            local function getServerConfig()
              local config = {}
              local camels = {
                { key = "AutomaticWorkspaceInit", default = 1 },
                { key = "WorkspaceModePeekDeepLevel", default = 4 },
                { key = "ExcludeProjectDirectories", default = {} },
                { key = "keywordsAutocomplete", default = 1 },
                { key = "ExternalAutocomplete", default = 0 },
                { key = "Linter", default = 1 },
                { key = "UnionCaseStubGeneration", default = 1 },
                { key = "UnionCaseStubGenerationBody" },
                { key = "RecordStubGeneration", default = 1 },
                { key = "RecordStubGenerationBody" },
                { key = "InterfaceStubGeneration", default = 1 },
                { key = "InterfaceStubGenerationObjectIdentifier", default = "this" },
                { key = "InterfaceStubGenerationMethodBody" },
                { key = "UnusedOpensAnalyzer", default = 1 },
                { key = "UnusedDeclarationsAnalyzer", default = 1 },
                { key = "SimplifyNameAnalyzer", default = 1 },
                { key = "ResolveNamespaces", default = 1 },
                { key = "EnableReferenceCodeLens", default = 1 },
                { key = "EnableAnalyzers", default = 1 },
                { key = "AnalyzersPath" },
                { key = "DisableInMemoryProjectReferences", default = 0 },
                { key = "LineLens", default = { enabled = "always", prefix = "//" } },
                { key = "UseSdkScripts", default = 1 },
                { key = "dotNetRoot" },
                { key = "fsiExtraParameters", default = {} },
              }
              local keys = buildConfigKeys(camels)

              for _, key in ipairs(keys) do

                if not vim.g['fsharp#' .. key.snake] then

                  vim.g['fsharp#' .. key.snake] = key.default or ""

                end

                if vim.g['fsharp#' .. key.snake] then
                  config[key.camel] = vim.g['fsharp#' .. key.snake]
                elseif vim.g['fsharp#' .. key.camel] then
                  config[key.camel] = vim.g['fsharp#' .. key.camel]
                elseif key.default and vim.g['fsharp#use_recommended_server_config'] then
                  vim.g['fsharp#' .. key.snake] = key.default
                  config[key.camel] = key.default
                end
              end
              return config
            end

            vim.g['fsharp#updateServerConfig'] = function()
              local settings = { fsharp = getServerConfig() }
              vim.g['fsharp#notify']("workspace/didChangeConfiguration", settings)
            end

            AddOrUpdateThenSort = function(value, tbl)
              -- print("attempting to add value " ..
              -- vim.inspect(value) .. " to Workspace table which looks like this : " .. vim.inspect(tbl))
              table.insert(tbl, value)

              -- print("after attempting to add value " ..
              -- vim.inspect(value) .. " to Workspace table, it now looks like this : " .. vim.inspect(tbl))
              table.sort(tbl)
              -- print("after sorting table, it now looks like this : " .. vim.inspect(tbl))
              return tbl
            end

            vim.g['fsharp#handle_notifyWorkspace'] = function(payload)
              local content = vim.json.decode(payload.content)
              if content then
                if content.Kind == 'projectLoading' then
                  print("[Ionide] Loading " .. content.Data.Project)
                  -- print("[Ionide] now calling AddOrUpdateThenSort on table  " .. vim.inspect(Workspace))
                  Workspace = AddOrUpdateThenSort(content.Data.Project, Workspace)

                  -- print("after attempting to reassign table value it looks like this : " .. vim.inspect(Workspace))
                elseif content.Kind == 'workspaceLoad' and content.Data.Status == 'finished' then
                  -- print("[Ionide] calling updateServerConfig ... ")

                  -- print("[Ionide] before calling updateServerconfig, workspace looks like:   " .. vim.inspect(Workspace))
                  vim.g['fsharp#updateServerConfig']()

                  -- print("[Ionide] after calling updateServerconfig, workspace looks like:   " .. vim.inspect(Workspace))
                  print("[Ionide] Workspace loaded (" .. #Workspace .. " project(s))")
                end
              end
            end

            local handlers = { ['fsharp/notifyWorkspace'] = "fsharp#handle_notifyWorkspace" }

            local function getHandlers()
              return handlers
            end

            vim.g['fsharp#create_handlers'] = function()
              local handlers = getHandlers()
              local r = {}
              for method, func_name in pairs(handlers) do
                local handler = function(err, params, ctx, _config)
                  if params == nil or not (method == ctx.method) then return end
                  vim.g[func_name](params)
                end
                r[method] = handler
              end
              M.handlers = r
              return r
            end

            local function load(arg)
              vim.g['fsharp#workspaceLoad'](arg, nil)
            end

            vim.g['fsharp#loadProject'] = function(...)
              local prjs = {}
              for _, proj in ipairs({ ... }) do
                table.insert(prjs, util.fnamemodify(proj, ':p'))
              end
              load(prjs)
            end

            vim.g['fsharp#showLoadedProjects'] = function()
              for _, proj in ipairs(Workspace) do
                print("- " .. proj)
              end
            end

            vim.g['fsharp#reloadProjects'] = function()
              if #Workspace > 0 then
                vim.g['fsharp#workspaceLoad'](Workspace, nil)
              else
                print("[Ionide] Workspace is empty")
              end
            end

            vim.g['fsharp#OnFSProjSave'] = function()
              if vim.bo.ft == "fsharp_project" and vim.g['fsharp#automatic_reload_workspace'] then
                vim.g['fsharp#reloadProjects']()
              end
            end

            vim.g['fsharp#loadConfig'] = function()

              vim.g['fsharp#fsautocomplete_command'] = { "fsautocomplete", "--adaptive-lsp-server-enabled", "-v" }
              vim.g['fsharp#use_recommended_server_config'] = 1
              -- getServerConfig()
              vim.g['fsharp#automatic_workspace_init'] = 1
              vim.g['fsharp#automatic_reload_workspace'] = 1
              vim.g['fsharp#show_signature_on_cursor_move'] = 1
              vim.g['fsharp#fsi_command'] = "dotnet fsi"
              vim.g['fsharp#fsi_keymap'] = "vscode"
              vim.g['fsharp#fsi_window_command'] = "botright 10new"
              vim.g['fsharp#fsi_focus_on_send'] = 0
              vim.g['fsharp#backend'] = "nvim"
              vim.g['fsharp#lsp_auto_setup'] = 0
              vim.g['fsharp#lsp_recommended_colorscheme'] = 1
              vim.g['fsharp#lsp_codelens'] = 1
              vim.g['fsharp#fsi_vscode_keymaps'] = 1
              vim.g['fsharp#statusline'] = "Ionide"
              vim.g['fsharp#autocmd_events'] = { "BufEnter", "BufWritePost", "CursorHold", "CursorHoldI", "InsertEnter",
                "InsertLeave" }
              vim.g['fsharp#fsi_keymap_send'] = "<M-cr>"
              vim.g['fsharp#fsi_keymap_toggle'] = "<M-@>"

              --astronvim.notify("fsautocomplete command is : " .. vim.inspect(vim.g['fsharp#fsautocomplete_command']))

              return getServerConfig()
            end

            -- function! fsharp#showSignature()
            --     function! s:callback_showSignature(result)
            --         let result = a:result
            --         if exists('result.result.content')
            --             let content = json_decode(result.result.content)
            --             if exists('content.Data')
            --                 echo substitute(content.Data, '\n\+$', ' ', 'g')
            --             endif
            --         endif
            --     endfunction
            --     call s:signature(expand('%:p'), line('.') - 1, col('.') - 1, function("s:callback_showSignature"))
            -- endfunction

            vim.g['fsharp#showSignature'] = function()
              local cbShowSignature = function(result)
                if result then
                  if result.result then
                    if result.result.content then
                      local content = vim.json.decode(result.result.content)
                      if content then
                        if content.Data then
                          -- Using gsub() instead of substitute() in Lua
                          -- and % instead of :
                          print(content.Data:gsub("\n+$", " "))
                        end
                      end
                    end
                  end
                end
              end
              vim.g['fsharp#signature'](vim.fn.expand("%:p"), vim.cmd.line('.') - 1, vim.cmd.col('.') - 1,
                cbShowSignature)
            end

            -- function! fsharp#OnCursorMove()
            --     if g:fsharp#show_signature_on_cursor_move
            --         call fsharp#showSignature()
            --     endif
            -- endfunction
            --
            vim.g['fsharp#OnCursorMove'] = function()
              if vim.g['fsharp#show_signature_on_cursor_move'] then
                vim.g['fsharp#showSignature']()
              end
            end



            vim.g['fsharp#registerAutocmds'] = function()

              --     if g:fsharp#backend == 'nvim' && g:fsharp#lsp_codelens
              if vim.g['fsharp#backend'] == 'nvim' and vim.g['fsharp#lsp_codelens'] == true or
                  vim.g['fsharp#lsp_codelens'] == 1 then

                print("fsharp.backend is nvim and lsp_codelens is true.. ")
                local is_available = astronvim.is_available
                -- local user_plugin_opts = astronvim.user_plugin_opts
                local namespace = vim.api.nvim_create_namespace
                local autocmd = vim.api.nvim_create_autocmd
                local a = vim.api
                local grp = vim.api.nvim_create_augroup
                local setlines = vim.api.nvim_buf_set_lines
                local jb = vim.fn.jobstart
                local uc = vim.api.nvim_create_user_command
                local inp = vim.fn.input


                autocmd({ "CursorHold,InsertLeave" }, {
                  desc = "FSharp Auto refresh code lens ",
                  group = grp("FSharp_AutoRefreshCodeLens", { clear = true }),
                  pattern = "*.fs,*.fsi,*.fsx",
                  callback = function() vim.lsp.codelens.refresh() end,
                })

                autocmd({ "CursorHold,InsertLeave" }, {
                  desc = "URL Highlighting",
                  group = grp("FSharp_AutoRefreshCodeLens", { clear = true }),
                  pattern = "*.fs,*.fsi,*.fsx",
                  callback = vim.g['fsharp#OnCursorMove'](),
                })

                --         augroup FSharp_AutoRefreshCodeLens
                --             autocmd!
                --             autocmd CursorHold,InsertLeave <buffer> lua
                --         augroup END
                --     endif
                --     if g:fsharp#backend != 'disable'
                --         augroup FSharp_OnCursorMove
                --             autocmd!
                --             autocmd CursorMoved *.fs,*.fsi,*.fsx  call fsharp#OnCursorMove()
                --         augroup END
                --     endif
                -- endfunction
                --
              end
            end

            vim.g['fsharp#initialize'] = function()
              print 'Ionide Initializing'
              print 'Ionide calling updateServerConfig...'
              vim.g['fsharp#updateServerConfig']()
              print 'Ionide calling registerAutocmds...'
              vim.g['fsharp#registerAutocmds']()
              print 'Ionide Initialized'
            end

            local function exists(filename)
              local stat = uv.fs_stat(filename)
              return stat and stat.type or false
            end

            local function is_dir(filename)
              return exists(filename) == "directory"
            end

            local function is_file(filename)
              return exists(filename) == "file"
            end

            local is_windows = uv.os_uname().version:match "Windows"
            local path_sep = is_windows and "\\" or "/"

            local is_fs_root
            if is_windows then
              is_fs_root = function(path)
                return path:match "^%a:$"
              end
            else
              is_fs_root = function(path)
                return path == "/"
              end
            end

            local function is_absolute(filename)
              if is_windows then
                return filename:match "^%a:" or filename:match "^\\\\"
              else
                return filename:match "^/"
              end
            end

            local dirname
            do
              local strip_dir_pat = path_sep .. "([^" .. path_sep .. "]+)$"
              local strip_sep_pat = path_sep .. "$"
              dirname = function(path)
                if not path or #path == 0 then
                  return
                end
                local result = path:gsub(strip_sep_pat, ""):gsub(strip_dir_pat, "")
                if #result == 0 then
                  return "/"
                end
                return result
              end
            end

            local function join(...)
              local result = table.concat(vim.tbl_flatten { ... }, path_sep):gsub(path_sep .. "+", path_sep)
              return result
            end

            -- Traverse the path calling cb along the way.
            local function traverse_parents(path, cb)
              path = uv.fs_realpath(path)
              local dir = path
              -- Just in case our algo is buggy, don't infinite loop.
              for _ = 1, 100 do
                dir = dirname(dir)
                if not dir then
                  return
                end
                -- If we can't ascend further, then stop looking.
                if cb(dir, path) then
                  return dir, path
                end
                if is_fs_root(dir) then
                  break
                end
              end
            end

            -- Iterate the path until we find the rootdir.
            local function iterate_parents(path)
              path = uv.fs_realpath(path) or path
              local function it(s, v)
                if not v then
                  return
                end
                if is_fs_root(v) then
                  return
                end
                return dirname(v), path
              end

              return it, path, path
            end

            local function is_descendant(root, path)
              if not path then
                return false
              end

              local function cb(dir, _)
                return dir == root
              end

              local dir, _ = traverse_parents(path, cb)

              return dir == root
            end

            local function search_ancestors(startpath, func)

              validate { func = { func, "f" } }
              if func(startpath) then
                return startpath
              end
              for path in iterate_parents(startpath) do
                if func(path) then
                  return path
                end
              end
            end

            local function root_pattern(...)
              local patterns = vim.tbl_flatten { ... }
              local function matcher(path)
                for _, pattern in ipairs(patterns) do
                  for _, p in ipairs(vim.fn.glob(join(path, pattern), true, true)) do
                    if exists(p) then
                      return path
                    end
                  end
                end
              end

              return function(startpath)
                return search_ancestors(startpath, matcher)
              end
            end

            local function find_git_ancestor(startpath)
              return search_ancestors(startpath, function(path)
                if is_dir(join(path, ".git")) then
                  return path
                end
              end)
            end

            local function get_default_config()
              local auto_init = vim.g['fsharp#automatic_workspace_init']
              local result = {
                name = "ionide",
                on_attach = astronvim.lsp.on_attach,
                cmd = { 'fsautocomplete', '--adaptive-lsp-server-enabled', '-v' },
                cmd_env = { DOTNET_ROLL_FORWARD = "LatestMajor" },
                filetypes = { "fsharp" },
                autostart = true,
                handlers = vim.g['fsharp#create_handlers'](),
                init_options = { AutomaticWorkspaceInit = (auto_init == 1) },
                on_init = vim.g['fsharp#initialize'],
                settings = { fsharp = vim.g['fsharp#loadConfig']() },
                root_dir = get_root_dir,
              }
              return result
            end

            -- M.manager = nil

            -- " " https://stackoverflow.com/a/6271254
            -- " function! s:get_visual_selection()
            -- "     let [line_start, column_start] = getpos("'<")[1:2]
            -- "     let [line_end, column_end] = getpos("'>")[1:2]
            -- "     let lines = getline(line_start, line_end)
            -- "     if len(lines) == 0
            -- "         return ''
            -- "     endif
            -- "     let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
            -- "     let lines[0] = lines[0][column_start - 1:]
            -- "     return lines
            -- " endfunction
            vim.g['fsharp#get_visual_selection']= function ()
              local line_start, column_start = unpack(vim.fn.getpos("'<"))
              local line_end, column_end = unpack(vim.fn.getpos("'>"))
              local lines = vim.fn.getline(line_start, line_end)
              if #lines == 0 then
                  return ''
              end
              lines[-1] = string.sub(lines[-1], 1, column_end - (vim.opt.selection == 'inclusive' and 1 or 2))
              lines[1] = string.sub(lines[1], column_start)
              return lines
            end            

            local function autostart_if_needed(m, config)
              local auto_setup = (vim.g['fsharp#lsp_auto_setup'] == 1)
              if auto_setup and not (config.autostart == false) then
                m.autostart()
              end
            end

            local function delegate_to_lspconfig(config)
              -- astronvim.notify("delegating to lspconfig for ionide")
              local lspconfig = require('lspconfig')
              local configs = require('lspconfig.configs')
              if not (configs['ionide']) then
                configs['ionide'] = {
                  default_config = get_default_config(),
                  docs = {
                    description = [[
            https://github.com/ionide/Ionide-vim
                  ]] ,
                  },
                }
              end
              lspconfig.ionide.setup(config)
            end

            --- ftplugin section ---

            --" Vim filetype plugin

            -- if exists('b:did_fsharp_project_ftplugin')
            --     finish
            -- endif
            -- let b:did_fsharp_project_ftplugin = 1
            --
            vim.filetype.add(
              {
                extension = {
                  fsproj = function(path, bufnr)
                    -- if some_condition() then
                    return 'fsharp_project', function(bufnr)
                      --Set a buffer variable

                      vim.bo.syntax.set = 'xml'
                      -- vim.b[bufnr] = 2
                      -- end
                    end
                  end,
                },
              })

            --let s:cpo_save = &cpo
            --set cpo&vim

            --augroup FSharpLC_fsproj
            -- autocmd! BufWritePost *.fsproj call fsharp#OnFSProjSave()
            --augroup END

            --let &cpo = s:cpo_save

            if not vim.g.filetype_fs then
              vim.g['filetype_fs'] = 'fsharp'
            end
            if not vim.g.filetype_fs == 'fsharp' then
              vim.g['filetype_fs'] = 'fsharp'
            end
            if vim.b.did_fsharp_ftplugin and vim.b.did_fsharp_ftplugin == 1 then
              return
            end
            vim.b.did_fsharp_ftplugin = 1

            local cpo_save = vim.o.cpo
            vim.o.cpo = ''

            -- enable syntax based folding
            vim.b.fdm = 'syntax'

            -- comment settings
            vim.b.formatoptions = 'croql'
            vim.b.commentstring = '(*%s*)'
            vim.b.comments = [[s0:*\ -,m0:*\ \ ,ex0:*),s1:(*,mb:*,ex:*),:\/\/\/,:\/\/]]

            -- make ftplugin undo-able
            vim.b.undo_ftplugin = 'setl fo< cms< com< fdm<'


            -- load configurations
            -- vim.g['fsharp#loadConfig']()


            -- local script_root_dir = vim.api.nvim_buf_get_name(0):match("(.*/).*") .. "/../"

            -- if vim.api.nvim_version() >= 500 then
            --   ionide = require("ionide")
            -- end
            
            local function prompt(msg)
              local height = vim.o.cmdheight
              if height < 2 then
                vim.o.cmdheight = 2
              end
              print(msg)
              vim.o.cmdheight = height
            end

            vim.o.cpo = cpo_save

            --- end ftplugin section ---
            -- vim.cmd "let g:fsharp#use_sdk_scripts = true"
            --
            -- astronvim.load_plugin_with_func("lspconfig", module, func_names)

            local con = {
              cmd = { "fsautocomplete", "--adaptive-lsp-server-enabled",
                -- "--project-graph-enabled",
                "-v" },
              settings = {
                fsharp = {
                  ["AutomaticWorkspaceInit"]                  = 1,
                  ["UnionCaseStubGeneration"]                 = 1,
                  ["EnableAnalyzers"]                         = 1,
                  ["ExternalAutocomplete"]                    = 0,
                  ["WorkspaceModePeekDeepLevel"]              = 4,
                  ["ExcludeProjectDirectories"]               = {},
                  ["UnusedDeclarationsAnalyzer"]              = 1,
                  ["EnableReferenceCodeLens"]                 = 1,
                  ["SimplifyNameAnalyzer"]                    = 1,
                  ["DisableInMemoryProjectReferences"]        = 0,
                  ["UnusedOpensAnalyzer"]                     = 1,
                  ["RecordStubGeneration"]                    = 1,
                  ["LineLens"]                                = {
                    ["enabled"] = "always",
                    ["prefix"] = "//",
                  },
                  ["UseSdkScripts"]                           = 1,
                  ["InterfaceStubGenerationObjectIdentifier"] = "this",
                  -- ["dotnetRoot"]                              = "C:/Program Files/dotnet/",
                  ["Linter"]                                  = 1,
                  ["fsiExtraParameters"]                      = {},
                  -- ["fsiSdkFilePath"]                      = {},
                  ["ResolveNamespaces"]                       = 1,
                  ["keywordsAutocomplete"]                    = 1,
                  ["InterfaceStubGeneration"]                 = 1,
                },
              },
            }
            -- return {

            delegate_to_lspconfig(con)



          end,

